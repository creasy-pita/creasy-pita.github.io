<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring-AOP-SourceCode-guide | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="spring aop 源码入口1 通过spring提供BeanPostProcessor的扩展点来完成aop增强AbstractAutowireCapableBeanFactory:applyBeanPostProcessorsAfterInitialization for (BeanPostProcessor processor : getBeanPostProcessors()) 如果有aop">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-AOP-SourceCode-guide">
<meta property="og:url" content="http://example.com/2021/05/13/Spring-AOP-SourceCode-guide/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="spring aop 源码入口1 通过spring提供BeanPostProcessor的扩展点来完成aop增强AbstractAutowireCapableBeanFactory:applyBeanPostProcessorsAfterInitialization for (BeanPostProcessor processor : getBeanPostProcessors()) 如果有aop">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/creasy-pita/MDimage/master/img/20210425182312.png">
<meta property="og:image" content="https://raw.githubusercontent.com/creasy-pita/MDimage/master/img/20210425182312.png">
<meta property="article:published_time" content="2021-05-13T01:29:51.000Z">
<meta property="article:modified_time" content="2021-05-13T02:01:54.870Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="aop">
<meta property="article:tag" content="sourcecode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/creasy-pita/MDimage/master/img/20210425182312.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Spring-AOP-SourceCode-guide" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/13/Spring-AOP-SourceCode-guide/" class="article-date">
  <time class="dt-published" datetime="2021-05-13T01:29:51.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring-AOP-SourceCode-guide
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="spring-aop-源码入口"><a href="#spring-aop-源码入口" class="headerlink" title="spring aop 源码入口"></a>spring aop 源码入口</h2><p>1 通过spring提供BeanPostProcessor的扩展点来完成aop增强<br>AbstractAutowireCapableBeanFactory:applyBeanPostProcessorsAfterInitialization <code>for (BeanPostProcessor processor : getBeanPostProcessors())</code></p>
<p>如果有aop切面，List<BeanPostProcessor>中会产生AbstractAutoProxyCreator类，调用AbstractAutoProxyCreator：postProcessAfterInitialization会进入spring aop增强处理的逻辑</p>
<p>:question:spring是否每次默认加载AbstractAutoProxyCreator(不重要)</p>
<h2 id="spring-aop-筛选合适的通知器并创建代理对象"><a href="#spring-aop-筛选合适的通知器并创建代理对象" class="headerlink" title="spring aop 筛选合适的通知器并创建代理对象"></a>spring aop 筛选合适的通知器并创建代理对象</h2><h3 id="1-AbstractAutoProxyCreator-postProcessAfterInitialization"><a href="#1-AbstractAutoProxyCreator-postProcessAfterInitialization" class="headerlink" title="1 AbstractAutoProxyCreator:postProcessAfterInitialization"></a>1 AbstractAutoProxyCreator:postProcessAfterInitialization</h3><h3 id="2-AbstractAutoProxyCreator-wrapIfNecessary-如果必要的话给目标类包装上aop增强"><a href="#2-AbstractAutoProxyCreator-wrapIfNecessary-如果必要的话给目标类包装上aop增强" class="headerlink" title="2 AbstractAutoProxyCreator:wrapIfNecessary 如果必要的话给目标类包装上aop增强"></a>2 AbstractAutoProxyCreator:wrapIfNecessary 如果必要的话给目标类包装上aop增强</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);<span class="comment">//&lt;1&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 若 specificInterceptors != null，即 specificInterceptors != DO_NOT_PROXY，</span></span><br><span class="line"><span class="comment">    * 则为 bean 生成代理对象，否则直接返回 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">    <span class="comment">//&lt;2&gt; 创建包含拦截器连的动态代理  </span></span><br><span class="line">    Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">    <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 返回代理对象，此时 IOC 容器输入 bean，得到 proxy。此时，</span></span><br><span class="line"><span class="comment">        * beanName 对应的 bean 是代理对象，而非原始的 bean</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="comment">// specificInterceptors = null，直接返回 bean,不会加入aop逻辑</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 中这里会过滤出当前beanname需要的advice(会用拦截器interceptor来处理)，具体查看<code>getAdvicesAndAdvisorsForBean</code>方法</li>
<li><code>&lt;2&gt;</code> 创建包含拦截器连的<a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a></li>
</ul>
<p>:question:<code>getAdvicesAndAdvisorsForBean</code>方法中的advisor bean对象在何时创建</p>
<h3 id="3-AbstractAutoProxyCreator-createProxy-给目标类创建代理"><a href="#3-AbstractAutoProxyCreator-createProxy-给目标类创建代理" class="headerlink" title="3 AbstractAutoProxyCreator:createProxy  给目标类创建代理"></a>3 AbstractAutoProxyCreator:createProxy  给目标类创建代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//根据isProxyTargetClass设置信息 确定基于JDK的动态代理还是基于CGLIB的动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-DefaultAopProxyFactory-createAopProxy"><a href="#4-DefaultAopProxyFactory-createAopProxy" class="headerlink" title="4 DefaultAopProxyFactory:createAopProxy"></a>4 DefaultAopProxyFactory:createAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="comment">/* creasypita</span></span><br><span class="line"><span class="comment">        * 下面的三个条件简单分析一下：</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *   条件1：config.isOptimize() - 是否需要优化，这个属性没怎么用过，</span></span><br><span class="line"><span class="comment">        *         细节我不是很清楚</span></span><br><span class="line"><span class="comment">        *   条件2：config.isProxyTargetClass() - 检测 proxyTargetClass 的值，</span></span><br><span class="line"><span class="comment">        *         前面的代码会设置这个值</span></span><br><span class="line"><span class="comment">        *   条件3：hasNoUserSuppliedProxyInterfaces(config)</span></span><br><span class="line"><span class="comment">        *         - 目标 bean 是否实现了接口</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-JdkDynamicAopProxy-getProxy-最终创建JDK动态代理，cglib动态代理先跳过"><a href="#5-JdkDynamicAopProxy-getProxy-最终创建JDK动态代理，cglib动态代理先跳过" class="headerlink" title="5 JdkDynamicAopProxy:getProxy 最终创建JDK动态代理，cglib动态代理先跳过"></a>5 JdkDynamicAopProxy:getProxy 最终创建JDK动态代理，cglib动态代理先跳过</h3><p>通过Proxy.newProxyInstance最终生成目标对象<code>this</code>的代理对象Proxy，后续从spring获取目标对象时获取的是这个Proxy</p>
<p>:star::star: todo 这边是关键部分，描述可以再准确些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&lt;1&gt; </span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="comment">//最终返回的是代理对象</span></span><br><span class="line">    <span class="comment">//todo this是什么需要说明 它应该是一个封装了目标对象的JdkDynamicAopProxy对象</span></span><br><span class="line">    <span class="comment">//&lt;2&gt; newProxyInstance的3个参数 ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h，</span></span><br><span class="line">    <span class="comment">//其中InvocationHandler 是JdkDynamicAopProxy,其封装了带有目标对象的属性，后续会有说明</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code>:question: todo  初步判断是拿到当前目标对象的接口，但感觉还进行了进一步的处理，后续可以关注下 (不重要)</li>
<li><code>&lt;2&gt;</code> newProxyInstance的3个参数 ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h，其中InvocationHandler 是JdkDynamicAopProxy,其封装了带有目标对象的属性，后续会有说明</li>
</ul>
<h2 id="拦截器链的执行过程"><a href="#拦截器链的执行过程" class="headerlink" title="拦截器链的执行过程"></a>拦截器链的执行过程</h2><p>为了方面说明,目标对象我们用<code>IUserService</code>作为示例</p>
<h3 id="1-调用service接口addUser方法-其实拿到的是动态代理类IUserService-Proxy0…"><a href="#1-调用service接口addUser方法-其实拿到的是动态代理类IUserService-Proxy0…" class="headerlink" title="1 调用service接口addUser方法,其实拿到的是动态代理类IUserService$Proxy0…"></a>1 调用service接口addUser方法,其实拿到的是动态代理类IUserService$Proxy0…</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IUserService aAopAdvicedUserService =  applicationContext.getBean(<span class="string">&quot;aAopAdvicedUserService&quot;</span>);</span><br><span class="line">aAopAdvicedUserService.addUser(user);</span><br></pre></td></tr></table></figure>

<h3 id="2-这里需要重点解读一下动态代理UserService-Proxy0的代码"><a href="#2-这里需要重点解读一下动态代理UserService-Proxy0的代码" class="headerlink" title="2  这里需要重点解读一下动态代理UserService$Proxy0的代码"></a>2  这里需要重点解读一下动态代理<code>UserService$Proxy0</code>的代码</h3><p>前面提到动态代理最终在<code>JdkDynamicAopProxy:getProxy</code>方法的<code>Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)</code>中创建，<br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984">Proxy.newProxyInstance</a><strong>动态代理生成机制实际上是jvm在运行期创建class字节码并加载的过程</strong>，字节码改写成静态实现类代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserService$Proxy0.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span>$<span class="title">Proxy0</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意这里的InvocationHandler  实际使用的是JdkDynamicAopProxy，它继承和实现了InvocationHandler</span></span><br><span class="line">    InvocationHandler handler;<span class="comment">//&lt;1&gt;</span></span><br><span class="line">    <span class="keyword">public</span> UserService$Proxy0(InvocationHandler handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&lt;2&gt; 这里是通过Proxy.newProxyInstance动态生成的IUserService接口的addUser方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           <span class="comment">//通过 Java reflection机制找到名称为addUser的Method</span></span><br><span class="line">           IUserService.class.getMethod(<span class="string">&quot;addUser&quot;</span>, String.class),</span><br><span class="line">           <span class="comment">//this is args of addUser method</span></span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; user &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 注意这里的InvocationHandler  实际使用的是JdkDynamicAopProxy，它继承和实现了InvocationHandler，所以调用<code>addUser</code>会调用JdkDynamicAopProxy:invoke方法</li>
<li><code>&lt;2&gt;</code> 这里是通过Proxy.newProxyInstance动态生成的IUserService接口的addUser方法,它是通过传入的<code>ClassLoader loader,Class&lt;?&gt;[] interfaces</code>两个参数来加载的</li>
</ul>
<h3 id="3-star-star-JdkDynamicAopProxy-invoke"><a href="#3-star-star-JdkDynamicAopProxy-invoke" class="headerlink" title="3 :star::star:JdkDynamicAopProxy:invoke"></a>3 :star::star:JdkDynamicAopProxy:invoke</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// &lt;0.1&gt; 获取目标对象 很明显它在JdkDynamicAopProxy对象中：this.advised.targetSource</span></span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//省略部分代码...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">//省略部分代码...</span></span><br><span class="line">        <span class="comment">//&lt;0.2&gt; 获取目标对象</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">        <span class="comment">//&lt;1&gt; 获取适合当前方法的拦截器链</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//&lt;2&gt; 如果拦截器链为空，则直接执行目标方法</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;3&gt; 创建一个方法调用器，并将拦截器链传入其中</span></span><br><span class="line">            MethodInvocation invocation =</span><br><span class="line">                    <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// 通过反射执行目标方法</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法返回值类型</span></span><br><span class="line">        <span class="comment">// Massage return value if necessary.</span></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">// 如果方法返回值为 this，即 return this; 则将代理对象 proxy 赋值给 retVal</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;0.1&gt; &lt;0.2&gt;</code> 获取目标对象 很明显它在JdkDynamicAopProxy对象中：this.advised.targetSource</li>
<li><code>&lt;1&gt;</code> 获取适合当前方法的拦截器链</li>
<li><code>&lt;2&gt;</code> 如果拦截器链为空，则直接执行目标方法</li>
<li><code>&lt;3&gt;</code> 创建一个方法调用器，并将拦截器链传入其中,:star::star::star::star:<code>MethodInvocation invocation =new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);invocation.proceed();</code></li>
<li>这里参数<code>proxy</code>在<code>invocation.proceed()</code>方法中并没有使用，但可能其他地方使用，所以创建时也同时传入</li>
</ul>
<h3 id="4-star-star-star-star-ReflectiveMethodInvocation-proceed开启拦截器链的执行"><a href="#4-star-star-star-star-ReflectiveMethodInvocation-proceed开启拦截器链的执行" class="headerlink" title="4 :star::star::star::star:ReflectiveMethodInvocation:proceed开启拦截器链的执行"></a>4 :star::star::star::star:ReflectiveMethodInvocation:proceed开启拦截器链的执行</h3><p>接下来上一步看一下创建方法调用器<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法</p>
<p>拦截器参考<code>[Interceptor](#拦截器Interceptor)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//&lt;1&gt; 拦截器链中的最后一个拦截器执行完后，即可执行目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="comment">// &lt;2&gt; </span></span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 调用具有三个参数（3-args）的 matches 方法动态匹配目标方法，</span></span><br><span class="line"><span class="comment">            * 两个参数（2-args）的 matches 方法用于静态匹配</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="comment">//&lt;2.1&gt; 调用拦截器逻辑</span></span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果匹配失败，则忽略当前的拦截器</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用拦截器逻辑，并传递 ReflectiveMethodInvocation 对象</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;2.1&gt;</code> 会调用拦截器的逻辑，这里我们可以以</li>
</ul>
<h3 id="5-拦截器链中单个拦截器的执行过程interceptor-invoke"><a href="#5-拦截器链中单个拦截器的执行过程interceptor-invoke" class="headerlink" title="5 拦截器链中单个拦截器的执行过程interceptor.invoke"></a>5 拦截器链中单个拦截器的执行过程interceptor.invoke</h3><p>aop中的返回通知(增强)AfterReturningAdviceInterceptor也是一种拦截器类，接下我们通过它作为示例来说明单个拦截器的执行过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AfterReturningAdviceInterceptor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">AfterAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AfterReturningAdvice advice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterReturningAdviceInterceptor</span><span class="params">(AfterReturningAdvice advice)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(advice, <span class="string">&quot;Advice must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;通过 MethodInvocation 调用下一个拦截器，若所有拦截器均执行完，则调用目标方法</span></span><br><span class="line">        Object retVal = mi.proceed();</span><br><span class="line">        <span class="comment">//&lt;2&gt; 执行后置通知逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span>, <span class="title">AfterAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AspectJAfterReturningAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(aspectJBeforeAdviceMethod, pointcut, aif);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldInvokeOnReturnValueOf(method, returnValue)) &#123;</span><br><span class="line">        <span class="comment">//&lt;3&gt;调用AbstractAspectJAdvice:invokeAdviceMethod方法</span></span><br><span class="line">        invokeAdviceMethod(getJoinPointMatch(), returnValue, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 通过 MethodInvocation 调用下一个拦截器，若所有拦截器均执行完，则调用目标方法</li>
<li><code>&lt;2&gt;</code> 执行返回通知逻辑,advice.afterReturning调用AspectJAfterReturningAdvice:afterReturning方法</li>
<li><code>&lt;3&gt;</code> 调用AbstractAspectJAdvice:invokeAdviceMethod方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAspectJAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span>, <span class="title">AspectJPrecedenceInformation</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> JoinPointMatch jpMatch, <span class="meta">@Nullable</span> Object returnValue, <span class="meta">@Nullable</span> Throwable ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;4&gt; 调用this.invokeAdviceMethodWithGivenArgs</span></span><br><span class="line">        <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] actualArgs = args;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            actualArgs = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">            <span class="comment">//&lt;5&gt; 通过`this.aspectInstanceFactory.getAspectInstance()`获取在之前加入Spring Bean容器中Aspect Bean</span></span><br><span class="line">            <span class="comment">//通过Java reflect  method.invoke(Object,Object... args)调用Aspect Bean的增强方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;4&gt;</code> 调用this.invokeAdviceMethodWithGivenArgs</li>
<li><code>&lt;5&gt;</code> 通过<code>this.aspectInstanceFactory.getAspectInstance()</code>获取在之前加入Spring Bean容器中Aspect Bean，通过Java reflect  method.invoke(Object,Object… args)调用Aspect Bean的增强方法。:star::star:AspectJAfterReturningAdvice类作为bean逻辑上是归属某个Aspect bean的，所以这里拿到这个方法Aspect Bean并通过反射调用具体的方法。这里涉及到一个<code>this.aspectInstanceFactory</code>是在AspectJAfterReturningAdvice类处理逻辑中赋值的</li>
</ul>
<p>这样最终会执行到@Aspect类的@Before部分的方法逻辑</p>
<h4 id="补充特殊的AspectJAroundAdvice"><a href="#补充特殊的AspectJAroundAdvice" class="headerlink" title="补充特殊的AspectJAroundAdvice"></a>补充特殊的AspectJAroundAdvice</h4><p>拦截器链中Around环绕方式的拦截器使用比较特殊，补充说明一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AspectJAfterAdvice.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//&lt;1.1&gt;执行下一个拦截器逻辑</span></span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//&lt;1.2&gt;执行后置增强</span></span><br><span class="line">        invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AspectJAroundAdvice.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">    ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">    JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">    <span class="comment">//&lt;2&gt; 只需要调用invokeAdviceMethod,around逻辑在具体aspect切面的@Around方法中实现</span></span><br><span class="line">    <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1.1&gt;</code>执行下一个拦截器逻辑</li>
<li><code>&lt;1.2&gt;</code>执行后置增强</li>
<li><code>&lt;2&gt;</code>只需要调用invokeAdviceMethod,around逻辑在具体aspect切面的@Around方法中实现</li>
</ul>
<p>spring源码中可以使用 AroundAdviceBindingTests测试查看效果</p>
<h4 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h4><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>创建动态代理分基于JDK的动态代理，基于CGLIB的动态代理   参考： <a target="_blank" rel="noopener" href="http://www.tianxiaobo.com/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/">http://www.tianxiaobo.com/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/</a></p>
<h2 id="补充aop相关的advisor的初始化过程"><a href="#补充aop相关的advisor的初始化过程" class="headerlink" title="补充aop相关的advisor的初始化过程"></a>补充aop相关的advisor的初始化过程</h2><p>在spring aop 中Aspect PoiontCut,Advice都会创建相关的Spring Bean来辅助完成aop过程</p>
<h3 id="1-Aspect-PoiontCut-Advice类BeanDefinition的加载"><a href="#1-Aspect-PoiontCut-Advice类BeanDefinition的加载" class="headerlink" title="1 Aspect PoiontCut,Advice类BeanDefinition的加载"></a>1 Aspect PoiontCut,Advice类BeanDefinition的加载</h3><p>advisor会有BeanDefinition,应该是在加载@Aspect BeanDefinition时同时加载完成的<br>1 加载xml形式的spring applicationContext上下文,入口是：<code>ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-content.xml&quot;, getClass());</code><br>2 接下来的调用栈如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(DefaultListableBeanFactory.java:<span class="number">898</span>)</span><br><span class="line">at org.springframework.beans.factory.support.BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionReaderUtils.java:<span class="number">166</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.processBeanDefinition(DefaultBeanDefinitionDocumentReader.java:<span class="number">321</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseDefaultElement(DefaultBeanDefinitionDocumentReader.java:<span class="number">203</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:<span class="number">182</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:<span class="number">155</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:<span class="number">98</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">520</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">396</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">337</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">305</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">188</span>)</span><br><span class="line">at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:<span class="number">124</span>)</span><br><span class="line">at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:<span class="number">94</span>)</span><br><span class="line">at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:<span class="number">130</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:<span class="number">637</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">522</span>)</span><br><span class="line">- locked &lt;<span class="number">0xdb2</span>&gt; (a java.lang.Object)</span><br><span class="line">at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:<span class="number">202</span>)</span><br></pre></td></tr></table></figure>

<p>3 ClassPathXmlApplicationContext为什么会使用XmlBeanDefinitionReader<br>因为 ClassPathXmlApplicationContext 继承了AbstractXmlApplicationContext,AbstractXmlApplicationContext:loadBeanDefinitions方法调用时会使用XmlBeanDefinitionReader</p>
<blockquote>
<p>:bulb: 这里需要关注下ClassPathXmlApplicationContext是一个组合的类,在类关系上它的上级链路有很多,不严谨的话可以说一个继承和实现了很多接口和类组合类,在上面的调用栈中,很多方法其实是ClassPathXmlApplicationContext本身或者它的上级类,接口的实现方法。这也说明了通过组合可以玩出一个功能丰富的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4 如下的xml可以扫描注册得到7个BeanDefinition<br>每个aop:after 会对应一个AspectJPointcutAdvisor,及其两个字段:一个advice: AspectJAfterAdvice ,一个pointcut PonitCut，具体参考<img src="https://raw.githubusercontent.com/creasy-pita/MDimage/master/img/20210425182312.png" alt="aop的advisor的初始化"></p>
<p><code>aop:after</code>对应BeanDefinition来说自定义的bean标签，需要特殊转化才可以，<strong>这个特殊转化是如何实现的</strong>待探索（不重要）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterAdviceBindingTests&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;testAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一个aop:after 的一个AspectJPointcutAdvisor,及其两个字段:一个advice: AspectJAfterAdvice ,一个pointcut PonitCut--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;oneIntArg&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* setAge(int)) and args(age)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;oneObjectArg&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* getAge()) and this(bean)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;oneObjectArg&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* getDoctor()) and target(bean)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;oneIntAndOneObject&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">pointcut</span>=<span class="string">&quot;execution(* setAge(..)) and args(age) and this(bean)&quot;</span> <span class="attr">arg-names</span>=<span class="string">&quot;age,bean&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;needsJoinPoint&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* getAge())&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;needsJoinPointStaticPart&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* getAge())&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.aspectj.AdviceBindingTestAspect&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是注解形式的则会使用</p>
</blockquote>
<h3 id="2-Aspect的Advisor-PoiontCut-Advice的Spring-Bean的创建"><a href="#2-Aspect的Advisor-PoiontCut-Advice的Spring-Bean的创建" class="headerlink" title="2 Aspect的Advisor,PoiontCut,Advice的Spring Bean的创建"></a>2 Aspect的Advisor,PoiontCut,Advice的Spring Bean的创建</h3><p>调用链如下,这里时有上往下<br>AbstractBeanFactory.doGetBean(“aAspectBeanName”)<br>AbstractAutowireCapableBeanFactory:createBean<br>AbstractAutowireCapableBeanFactory:resolveBeforeInstantiation<br>AbstractAutowireCapableBeanFactory:applyBeanPostProcessorsBeforeInstantiation<br>AbstractAutoProxyCreator:postProcessBeforeInstantiation<br>AbstractAdvisorAutoProxyCreator:findCandidateAdvisors<br>BeanFactoryAdvisorRetrievalHelper:findAdvisorBeans</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutoProxyCreator.java</span></span><br><span class="line"><span class="comment">//&lt;1&gt; 通过BeanPostProcessors找到aop相关的AbstractAutoProxyCreator来创建Aspect相关的PoiontCut,Advice</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//&lt;1.1&gt; 根据beanName（一个Aspect）及xml中aop:config的ref 关联可以确定AdvicesAndAdvisors</span></span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// creasypita 查找所有的通知器</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">/*&lt;2&gt;</span></span><br><span class="line"><span class="comment">        * 筛选可应用在 beanClass 上的 Advisor，通过 ClassFilter 和 MethodMatcher</span></span><br><span class="line"><span class="comment">        * 对目标类和方法进行匹配</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code>中通过BeanPostProcessors找到aop相关的AbstractAutoProxyCreator来创建Aspect相关的PoiontCut和Advice;由此可知,还是通过AbstractAutoProxyCreator，一个实现BeanPostProcessor的aop相关类来扩展这部分逻辑</li>
<li><code>&lt;1.1&gt;</code>根据beanName（一个Aspect）及xml中aop:config的ref 关联可以确定AdvicesAndAdvisors<br>根据AbstractAutoProxyCreator:getAdvicesAndAdvisorsForBean最终定位到AbstractAdvisorAutoProxyCreator:findEligibleAdvisors方法</li>
<li><code>&lt;2&gt;</code> 通过ClassFilter 和 MethodMatcher筛选出匹配的Advisors（这里的advice,pointcut是作为Advisors实现类的属性字段的）<br>比如 AspectJPointcutAdvisor,AspectJAfterAdvice,AspectJExpressionPointcut</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BeanFactoryAdvisorRetrievalHelper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">    <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//&lt;2&gt; 创建advisors</span></span><br><span class="line">    <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">            <span class="comment">//省略部分代码</span></span><br><span class="line">            advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;2&gt;</code>中创建Aspect相关的advisors,如下所示：advisor中组合依赖了PoiontCut,Advice</li>
</ul>
<p><img src="https://raw.githubusercontent.com/creasy-pita/MDimage/master/img/20210425182312.png" alt="aop的advisor的初始化"></p>
<h2 id="补充从架构设计中类设计的角度的看法"><a href="#补充从架构设计中类设计的角度的看法" class="headerlink" title="补充从架构设计中类设计的角度的看法"></a>补充从架构设计中类设计的角度的看法</h2><p>类，接口的单一职责原则<br>类和接口的多重组合产生一个功能丰富但结构清晰的类</p>
<p>比如 ApplicationContext类<br>ApplicationContext作用<br>1.标识一个应用环境<br>2.利用BeanFactory创建Bean对象<br>3.:question:保存对象关系表<br>4.:question:能够捕获各种事件</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1 JdkDynamicAopProxy中对advisor 和target class 的处理</p>
<p>参考： <a target="_blank" rel="noopener" href="http://www.tianxiaobo.com/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/#3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">http://www.tianxiaobo.com/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/#3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90</a></p>
<p>2 执行拦截器链中为什么还要分析通知advisor对应的interceptor是否匹配执行，不是在形成拦截器链时就筛选出来匹配的通知advisor才会加入拦截器链的么？</p>
<p>3 BeanPostProcesser如何加载</p>
<p>AbstractApplicationContext:prepareBeanFactory方法中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如 其中的<code>AbstractAutoProxyCreator</code>应该时spring默认会加载的</p>
<p>4 Aspect注解类会解析出 AspectJPointcutAdvisor,Advice,AspectJExpressionPointcut类,什么时候解析以及作用是什么</p>
<p>Advice的实现类： AfterReturningAdvice</p>
<p>5 aspect advice pointcut 在代码上的关系</p>
<p>前面提到的<code>AbstractAspectJAdvice:invokeAdviceMethodWithGivenArgs</code>方法会使用<code>this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);</code>找到aspect对象并调用指定的连接点方法<br>所以advice是一个拦截器，可以被拦截器链执行到，并在器invoke方法中调用真正的连接点方法</p>
<p>6 todo advisor什么时候创建</p>
<p>估计答案在调用BeanPostProcesser扩展aop增强的AbstractAutoProxyCreator类时，会去先创建所有的aop相关bean，需要进一步探索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BeanFactoryAdvisorRetrievalHelper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">    <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//&lt;1&gt; 调用beanFactory.getBean获取</span></span><br><span class="line">                    advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;1&gt;</code>拿到合格的Advisor 然后调用beanFactory.getBean获取</p>
<p>7 BeanPostProcesser是每个getBean都会去调用的逻辑<br>是的<br>ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 Bean 中<br>原因 比如每个bean都有可能需要进行aop增强</p>
<p>参考 <a target="_blank" rel="noopener" href="http://www.tianxiaobo.com/2018/06/17/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/#34-%E5%88%87%E9%9D%A2-aspect">田小波 Spring-AOP-源码分析系列文章导读</a><br>调试方式:<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-context/src/test/java/org/springframework/aop/aspectj/AfterAdviceBindingTests.java">https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-context/src/test/java/org/springframework/aop/aspectj/AfterAdviceBindingTests.java</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/Spring-AOP-SourceCode-guide/" data-id="ckom9kwbq0005w4v710hs82tn" data-title="Spring-AOP-SourceCode-guide" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aop/" rel="tag">aop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sourcecode/" rel="tag">sourcecode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/13/hexo%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          hexo搭建使用记录
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aop/" rel="tag">aop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/" rel="tag">framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sourcecode/" rel="tag">sourcecode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/aop/" style="font-size: 10px;">aop</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/framework/" style="font-size: 10px;">framework</a> <a href="/tags/sourcecode/" style="font-size: 10px;">sourcecode</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/13/hexo%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">hexo搭建使用记录</a>
          </li>
        
          <li>
            <a href="/2021/05/13/Spring-AOP-SourceCode-guide/">Spring-AOP-SourceCode-guide</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>